name: DirectOutput Build

on:
  push:
  pull_request:
  workflow_dispatch:

defaults:
  run:
    shell: pwsh

jobs:
  build:
    name: Build DirectOutput-${{ matrix.config }}-win-${{ matrix.platform }}
    runs-on: windows-2022
    outputs:
      version-tag: ${{ steps.version.outputs.tag }}
      base-version: ${{ steps.version.outputs.base_version }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: x86
            config: Release
          - platform: x64
            config: Release
          # - platform: x86
          #   config: Debug
          # - platform: x64
          #   config: Debug

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup MSBuild and Visual Studio
        uses: microsoft/setup-msbuild@v2

      - name: Add Visual Studio to PATH and setup C++ environment
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: ${{ matrix.platform }}
          
      - name: Verify C++ build environment
        run: |
          Write-Host "=== C++ Build Environment Check ==="
          
          # Check for cl.exe compiler
          try {
            $clVersion = & cl 2>&1 | Select-String "Microsoft.*Compiler"
            Write-Host "✅ Found C++ Compiler: $clVersion"
          } catch {
            Write-Error "❌ C++ Compiler (cl.exe) not found"
            exit 1
          }
          
          # Check for link.exe linker
          try {
            $linkVersion = & link 2>&1 | Select-String "Microsoft.*Linker"
            Write-Host "✅ Found Linker: $linkVersion"
          } catch {
            Write-Error "❌ Linker (link.exe) not found"
            exit 1
          }
          
          # List available VS installations
          $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (Test-Path $vsWhere) {
            Write-Host "=== Available Visual Studio Installations ==="
            & $vsWhere -products * -format json | ConvertFrom-Json | ForEach-Object {
              Write-Host "Product: $($_.displayName) - Version: $($_.installationVersion)"
            }
          }
          
          Write-Host "=== Environment Variables ==="
          Write-Host "Platform: ${{ matrix.platform }}"
          Write-Host "VSCMD_ARG_TGT_ARCH: $env:VSCMD_ARG_TGT_ARCH"
          Write-Host "WindowsSDKVersion: $env:WindowsSDKVersion"

      - name: Install WiX Toolset v3.14
        if: matrix.config == 'Release'
        run: |
          # Download and install WiX Toolset v3.14.0 command-line tools
          Write-Host "Downloading WiX Toolset v3.14.0..."
          try {
            Invoke-WebRequest -Uri "https://github.com/wixtoolset/wix3/releases/download/wix314rtm/wix314.exe" -OutFile "wix314.exe" -UseBasicParsing
            Write-Host "Downloaded WiX installer: $(Get-Item wix314.exe | Select-Object Name, Length)"
          } catch {
            Write-Error "Failed to download WiX installer: $($_.Exception.Message)"
            exit 1
          }
          
          Write-Host "Installing WiX Toolset command-line tools..."
          try {
            $process = Start-Process -FilePath ".\wix314.exe" -ArgumentList "/quiet" -Wait -PassThru
            Write-Host "WiX installer exit code: $($process.ExitCode)"
            if ($process.ExitCode -ne 0) {
              Write-Error "WiX installer failed with exit code: $($process.ExitCode)"
              exit 1
            }
          } catch {
            Write-Error "Failed to run WiX installer: $($_.Exception.Message)"
            exit 1
          }
          
          # Verify command-line tools installation
          $wixPath = "C:\Program Files (x86)\WiX Toolset v3.14\bin"
          if (Test-Path $wixPath) {
            Write-Host "WiX Toolset command-line tools installed successfully at: $wixPath"
            # Add WiX to PATH for this step and subsequent steps
            echo "$wixPath" >> $env:GITHUB_PATH
            # Also set environment variable that MSBuild looks for
            echo "WIX=$($wixPath.Replace('\bin', ''))" >> $env:GITHUB_ENV
            
            # Verify key WiX tools are available
            $tools = @("candle.exe", "light.exe", "heat.exe")
            foreach ($tool in $tools) {
              if (Test-Path "$wixPath\$tool") {
                Write-Host "✅ Found $tool"
              } else {
                Write-Warning "⚠️ Missing $tool"
              }
            }
          } else {
            Write-Error "WiX Toolset command-line tools installation failed - path not found: $wixPath"
            exit 1
          }
          
          # Install WiX v3 - Visual Studio 2022 Extension
          Write-Host "Installing WiX v3 - Visual Studio 2022 Extension..."
          
          # Download the WiX VS2022 extension VSIX file
          try {
            $vsixUrl = "https://marketplace.visualstudio.com/_apis/public/gallery/publishers/WixToolset/vsextensions/WixToolsetVisualStudio2022Extension/1.0.0.22/vspackage"
            $vsixPath = "WixToolsetVisualStudio2022Extension.vsix"
            Invoke-WebRequest -Uri $vsixUrl -OutFile $vsixPath -UseBasicParsing
            Write-Host "Downloaded WiX VS extension: $(Get-Item $vsixPath | Select-Object Name, Length)"
          } catch {
            Write-Warning "Failed to download WiX VS extension: $($_.Exception.Message)"
            Write-Host "Continuing without VS extension - command-line tools should still work"
            return
          }
          
          # Install the VSIX extension using VSIXInstaller
          $vsixInstaller = $null
          $vsEditions = @("Enterprise", "Professional", "Community", "BuildTools")
          foreach ($edition in $vsEditions) {
            $testPath = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2022\$edition\Common7\IDE\VSIXInstaller.exe"
            if (Test-Path $testPath) {
              $vsixInstaller = $testPath
              Write-Host "Found VSIXInstaller for $edition edition"
              break
            }
          }
          
          if ($vsixInstaller) {
            try {
              Write-Host "Installing WiX VS2022 extension using: $vsixInstaller"
              $process = Start-Process -FilePath $vsixInstaller -ArgumentList "/quiet", "/admin", $vsixPath -Wait -PassThru
              Write-Host "VSIX installer exit code: $($process.ExitCode)"
              if ($process.ExitCode -eq 0) {
                Write-Host "✅ WiX VS2022 extension installation completed successfully"
              } else {
                Write-Warning "⚠️ WiX VS2022 extension installation may have failed (exit code: $($process.ExitCode))"
              }
            } catch {
              Write-Warning "Failed to install WiX VS extension: $($_.Exception.Message)"
            }
          } else {
            Write-Warning "VSIXInstaller not found. WiX extension may not be installed, but command-line tools should still work for MSBuild."
            Write-Host "Available VS installations:"
            Get-ChildItem "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2022" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.Name)" }
          }

      - name: Download and setup NuGet
        run: |
          Invoke-WebRequest -Uri "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe" -OutFile "nuget.exe"

      - name: Restore NuGet packages
        run: |
          .\nuget.exe restore DirectOutput.sln

      - name: Update Assembly Version
        id: version
        run: |
          # Extract base version from SharedAssemblyInfo.cs
          $sharedAssemblyInfo = "AssemblyInfo/SharedAssemblyInfo.cs"
          $content = Get-Content $sharedAssemblyInfo -Raw
          
          # Extract version using regex - looking for [assembly: AssemblyVersion("x.y.*")]
          if ($content -match '\[assembly:\s*AssemblyVersion\("([0-9]+\.[0-9]+)\.\*"\)\]') {
            $BASE_VERSION = $matches[1]
            Write-Host "Extracted base version from AssemblyInfo: $BASE_VERSION"
          } else {
            Write-Error "Could not extract base version from AssemblyInfo file"
            exit 1
          }
          
          $SHA7 = "${{ github.sha }}".Substring(0, 7)
          $VERSION_SHORT = "$BASE_VERSION.${{ github.run_number }}.0"
          $VERSION_LONG = "$BASE_VERSION.${{ github.run_number }}.0-$SHA7"
          
          Write-Host "VERSION_SHORT: $VERSION_SHORT"
          Write-Host "VERSION_LONG: $VERSION_LONG"
          
          # Update SharedAssemblyInfo.cs - use the extracted base version in the regex
          $content = $content + "`n[assembly: AssemblyFileVersion(`"$VERSION_SHORT`")]`n[assembly: AssemblyInformationalVersion(`"$VERSION_LONG`")]"
          Set-Content $sharedAssemblyInfo $content
          
          echo "tag=$VERSION_LONG" >> $env:GITHUB_OUTPUT
          echo "short_version=$VERSION_SHORT" >> $env:GITHUB_OUTPUT
          echo "base_version=$BASE_VERSION" >> $env:GITHUB_OUTPUT

      - name: Fix NuGet package references
        run: |
          # Fix missing System.Reflection.Metadata reference for DOFSetupPBXFixup
          Write-Host "Adding System.Reflection.Metadata NuGet package to DOFSetupPBXFixup..."
          
          # Create packages.config for DOFSetupPBXFixup if it doesn't exist
          echo '<?xml version="1.0" encoding="utf-8"?>' > DOFSetupPBXFixup\packages.config
          echo '<packages>' >> DOFSetupPBXFixup\packages.config
          echo '  <package id="System.Reflection.Metadata" version="8.0.0" targetFramework="net48" />' >> DOFSetupPBXFixup\packages.config
          echo '</packages>' >> DOFSetupPBXFixup\packages.config
          
          # Install the package with explicit directories
          Write-Host "Restoring NuGet packages for DOFSetupPBXFixup..."
          .\nuget.exe restore DOFSetupPBXFixup\DOFSetupPBXFixup.csproj -PackagesDirectory packages -SolutionDirectory .
          
          # Also install the specific package directly
          .\nuget.exe install System.Reflection.Metadata -Version 8.0.0 -OutputDirectory packages -Framework net48
          
          # Verify package was installed
          if (Test-Path "packages\System.Reflection.Metadata.8.0.0") {
            Write-Host "✅ System.Reflection.Metadata package installed successfully"
            Get-ChildItem "packages\System.Reflection.Metadata.8.0.0\lib" -Recurse -Name "*.dll" | ForEach-Object { Write-Host "  Found: $_" }
          } else {
            Write-Error "❌ System.Reflection.Metadata package not found in packages directory"
          }
          
          # Fix the project reference to include HintPath
          Write-Host "Fixing System.Reflection.Metadata reference in DOFSetupPBXFixup.csproj..."
          $projectFile = "DOFSetupPBXFixup\DOFSetupPBXFixup.csproj"
          $content = Get-Content $projectFile -Raw
          
          # Replace the hardcoded reference with proper NuGet package reference
          $oldRef = 'System.Reflection.Metadata, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" />'
          $newRef = 'System.Reflection.Metadata, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL"><HintPath>..\packages\System.Reflection.Metadata.8.0.0\lib\net462\System.Reflection.Metadata.dll</HintPath><Private>True</Private></Reference>'
          
          $content = $content -replace $oldRef, $newRef
          Set-Content $projectFile $content
          Write-Host "✅ Updated project reference with HintPath"

      - name: Build DirectOutput solution
        run: |
          Write-Host ">>> Building ${{ matrix.config }}|${{ matrix.platform }}"
          
          # Clean first (like BuildRelease.bat)
          Write-Host "Cleaning previous builds..."
          msbuild DirectOutput.sln -t:Clean -p:Configuration=${{ matrix.config }} -p:Platform=${{ matrix.platform }} -v:minimal -nologo
          if ($LASTEXITCODE -ne 0) { 
            Write-Error "Clean failed"
            exit $LASTEXITCODE 
          }
          
          # Build the entire solution (like BuildRelease.bat)
          Write-Host "Building complete solution..."
          msbuild DirectOutput.sln -t:Build -p:Configuration=${{ matrix.config }} -p:Platform=${{ matrix.platform }} -v:minimal -nologo
          if ($LASTEXITCODE -ne 0) { 
            Write-Error "Solution build failed"
            exit $LASTEXITCODE 
          }
          
          Write-Host "✅ Solution build completed successfully"

      - name: Create ZIP release package
        if: matrix.config == 'Release'
        run: |
          # Create output directory for ZIP package
          $outputDir = "output-zip-${{ matrix.platform }}-${{ matrix.config }}"
          New-Item -ItemType Directory -Path $outputDir -Force
          
          # Define source directory for binaries
          $binDir = "bin\${{ matrix.platform }}\${{ matrix.config }}"
          
          # Read manifest file and copy files
          $manifestFile = "manifest.${{ matrix.platform }}.txt"
          if (Test-Path $manifestFile) {
            Get-Content $manifestFile | Where-Object { $_ -notmatch "^#" -and $_.Trim() -ne "" } | ForEach-Object {
              $sourceFile = Join-Path $binDir $_
              if (Test-Path $sourceFile) {
                Copy-Item $sourceFile $outputDir -Force
                Write-Host "Copied: $sourceFile"
              } else {
                Write-Warning "File not found: $sourceFile"
              }
            }
          }
          
          # Copy additional files
          if (Test-Path "LICENSE") {
            Copy-Item "LICENSE" $outputDir -Force
          }
          
          # Copy config examples
          if (Test-Path "config\examples") {
            New-Item -ItemType Directory -Path "$outputDir\config\examples" -Force
            Copy-Item "config\examples\*.xml" "$outputDir\config\examples" -Force -ErrorAction SilentlyContinue
          }

      - name: Create MSI release package
        if: matrix.config == 'Release' && matrix.platform == 'x86'
        run: |
          # Create output directory for MSI package
          $outputDir = "output-msi-${{ matrix.platform }}-${{ matrix.config }}"
          New-Item -ItemType Directory -Path $outputDir -Force
          
          # Copy MSI installer
          $msiPath = "DOFSetup\bin\${{ matrix.platform }}\${{ matrix.config }}\DOFSetup.msi"
          if (Test-Path $msiPath) {
            $SHA7 = "${{ github.sha }}".Substring(0, 7)
            $DATE = Get-Date -Format "yyyyMMdd"
            $msiName = "DirectOutput-${{ matrix.platform }}-${{ matrix.config }}-$DATE-$SHA7.msi"
            Copy-Item $msiPath "$outputDir\$msiName" -Force
            Write-Host "Created MSI package: $msiName"
          } else {
            Write-Error "MSI installer not found at: $msiPath"
            exit 1
          }

      - name: Upload ZIP artifacts
        uses: actions/upload-artifact@v4
        with:
          name: DirectOutput-${{ steps.version.outputs.tag }}-${{ matrix.config }}-${{ matrix.platform }}.zip
          path: output-zip-${{ matrix.platform }}-${{ matrix.config }}
          if-no-files-found: warn

      - name: Upload MSI artifacts
        if: matrix.config == 'Release' && matrix.platform == 'x86'
        uses: actions/upload-artifact@v4
        with:
          name: DirectOutput-${{ steps.version.outputs.tag }}-${{ matrix.config }}-${{ matrix.platform }}.msi
          path: output-msi-${{ matrix.platform }}-${{ matrix.config }}
          if-no-files-found: error

  create-github-release:
    name: Create GitHub Release
    runs-on: windows-2022
    needs: build
    if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main') && startsWith(github.ref, 'refs/tags/')
    
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release files
        run: |
          # Use version information from build job outputs
          $VERSION_LONG = "${{ needs.build.outputs.version-tag }}"
          $BASE_VERSION = "${{ needs.build.outputs.base-version }}"
          $DATE = Get-Date -Format "yyyyMMdd"
          
          Write-Host "Using version from build job: $VERSION_LONG (base: $BASE_VERSION)"
          
          # Create release directory
          New-Item -ItemType Directory -Path "release" -Force
          
          # Process ZIP artifacts and create final ZIP packages
          @("x86", "x64") | ForEach-Object {
            $platform = $_
            $zipArtifactPath = "artifacts\DirectOutput-$VERSION_LONG-Release-$platform.zip"
            
            if (Test-Path $zipArtifactPath) {
              $zipName = "DirectOutput-release-$platform-$DATE.zip"
              $zipPath = "release\$zipName"
              
              # Create ZIP using PowerShell
              Compress-Archive -Path "$zipArtifactPath\*" -DestinationPath $zipPath -Force
              Write-Host "Prepared release ZIP: $zipPath"
            } else {
              Write-Warning "ZIP artifact not found: $zipArtifactPath"
            }
          }
          
          # Copy MSI installer directly (x86 only) - no need to zip MSI files
          $msiArtifactPath = "artifacts\DirectOutput-$VERSION_LONG-Release-x86.msi"
          if (Test-Path $msiArtifactPath) {
            Get-ChildItem "$msiArtifactPath\*.msi" | ForEach-Object {
              $msiDestPath = "release\$($_.Name)"
              Copy-Item $_.FullName $msiDestPath -Force
              Write-Host "Prepared release MSI: $msiDestPath"
            }
          } else {
            Write-Warning "MSI artifact not found: $msiArtifactPath"
          }

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: release/*
          tag_name: ${{ github.ref_name }}
          name: DirectOutput ${{ github.ref_name }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
