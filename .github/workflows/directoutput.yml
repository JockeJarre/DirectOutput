name: DirectOutput Build

on:
  push:
  pull_request:
  workflow_dispatch:

defaults:
  run:
    shell: pwsh

jobs:
  build:
    name: Build DirectOutput Release (x86 then x64)
    runs-on: windows-2022
    outputs:
      version-tag: ${{ steps.version.outputs.tag }}
      base-version: ${{ steps.version.outputs.base_version }}
    # strategy:
    #   fail-fast: false
    #   matrix:
    #     include:
    #       - platform: x86
    #         config: Release
    #       - platform: x64
    #         config: Release
    #       # - platform: x86
    #       #   config: Debug
    #       # - platform: x64
    #       #   config: Debug

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup MSBuild and Visual Studio
        uses: microsoft/setup-msbuild@v2

      - name: Add Visual Studio to PATH and setup C++ environment
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x86  # Start with x86 for initial setup
          
      - name: Verify C++ build environment
        run: |
          Write-Host "=== C++ Build Environment Check ==="
          
          # Check for cl.exe compiler
          try {
            $clVersion = & cl 2>&1 | Select-String "Microsoft.*Compiler"
            Write-Host "✅ Found C++ Compiler: $clVersion"
          } catch {
            Write-Error "❌ C++ Compiler (cl.exe) not found"
            exit 1
          }
          
          # Check for link.exe linker
          try {
            $linkVersion = & link 2>&1 | Select-String "Microsoft.*Linker"
            Write-Host "✅ Found Linker: $linkVersion"
          } catch {
            Write-Error "❌ Linker (link.exe) not found"
            exit 1
          }
          
          # List available VS installations
          $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (Test-Path $vsWhere) {
            Write-Host "=== Available Visual Studio Installations ==="
            & $vsWhere -products * -format json | ConvertFrom-Json | ForEach-Object {
              Write-Host "Product: $($_.displayName) - Version: $($_.installationVersion)"
            }
          }
          
          Write-Host "=== Environment Variables ==="
          Write-Host "VSCMD_ARG_TGT_ARCH: $env:VSCMD_ARG_TGT_ARCH"
          Write-Host "WindowsSDKVersion: $env:WindowsSDKVersion"

      - name: Install WiX Toolset v6
        run: |
          # Install WiX 6 .NET tool globally
          Write-Host "Installing WiX Toolset v6.0 as .NET global tool..."
          dotnet tool install --global wix --version 6.0.2
          
          # Add WiX UI extension
          Write-Host "Installing WiX UI extension..."  
          wix extension add WixToolset.UI.wixext
          
          # Verify installation
          Write-Host "Verifying WiX installation..."
          wix --version
          
          Write-Host "✅ WiX 6 installation completed successfully"

      - name: Download and setup NuGet
        run: |
          Invoke-WebRequest -Uri "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe" -OutFile "nuget.exe"

      - name: Restore NuGet packages
        run: |
          .\nuget.exe restore DirectOutput.sln

      - name: Update Assembly Version
        id: version
        run: |
          # Extract base version from SharedAssemblyInfo.cs
          $sharedAssemblyInfo = "AssemblyInfo/SharedAssemblyInfo.cs"
          $content = Get-Content $sharedAssemblyInfo -Raw
          
          # Extract version using regex - looking for [assembly: AssemblyVersion("x.y.*")]
          if ($content -match '\[assembly:\s*AssemblyVersion\("([0-9]+\.[0-9]+)\.\*"\)\]') {
            $BASE_VERSION = $matches[1]
            Write-Host "Extracted base version from AssemblyInfo: $BASE_VERSION"
          } else {
            Write-Error "Could not extract base version from AssemblyInfo file"
            exit 1
          }
          
          $SHA7 = "${{ github.sha }}".Substring(0, 7)
          $VERSION_SHORT = "$BASE_VERSION.${{ github.run_number }}.0"
          $VERSION_LONG = "$BASE_VERSION.${{ github.run_number }}.0-$SHA7"
          
          Write-Host "VERSION_SHORT: $VERSION_SHORT"
          Write-Host "VERSION_LONG: $VERSION_LONG"
          
          # Update SharedAssemblyInfo.cs - use the extracted base version in the regex
          $content = $content + "`n[assembly: AssemblyFileVersion(`"$VERSION_SHORT`")]`n[assembly: AssemblyInformationalVersion(`"$VERSION_LONG`")]"
          Set-Content $sharedAssemblyInfo $content
          
          echo "tag=$VERSION_LONG" >> $env:GITHUB_OUTPUT
          echo "short_version=$VERSION_SHORT" >> $env:GITHUB_OUTPUT
          echo "base_version=$BASE_VERSION" >> $env:GITHUB_OUTPUT

      - name: Fix NuGet package references
        run: |
          # Fix missing System.Reflection.Metadata reference for DOFSetupPBXFixup
          Write-Host "Adding System.Reflection.Metadata NuGet package to DOFSetupPBXFixup..."
          
          # Create packages.config for DOFSetupPBXFixup if it doesn't exist
          echo '<?xml version="1.0" encoding="utf-8"?>' > DOFSetupPBXFixup\packages.config
          echo '<packages>' >> DOFSetupPBXFixup\packages.config
          echo '  <package id="System.Reflection.Metadata" version="8.0.0" targetFramework="net48" />' >> DOFSetupPBXFixup\packages.config
          echo '</packages>' >> DOFSetupPBXFixup\packages.config
          
          # Install the package with explicit directories
          Write-Host "Restoring NuGet packages for DOFSetupPBXFixup..."
          .\nuget.exe restore DOFSetupPBXFixup\DOFSetupPBXFixup.csproj -PackagesDirectory packages -SolutionDirectory .
          
          # Also install the specific package directly
          .\nuget.exe install System.Reflection.Metadata -Version 8.0.0 -OutputDirectory packages -Framework net48
          
          # Verify package was installed
          if (Test-Path "packages\System.Reflection.Metadata.8.0.0") {
            Write-Host "✅ System.Reflection.Metadata package installed successfully"
            Get-ChildItem "packages\System.Reflection.Metadata.8.0.0\lib" -Recurse -Name "*.dll" | ForEach-Object { Write-Host "  Found: $_" }
          } else {
            Write-Error "❌ System.Reflection.Metadata package not found in packages directory"
          }
          
          # Fix the project reference to include HintPath
          Write-Host "Fixing System.Reflection.Metadata reference in DOFSetupPBXFixup.csproj..."
          $projectFile = "DOFSetupPBXFixup\DOFSetupPBXFixup.csproj"
          $content = Get-Content $projectFile -Raw
          
          # Replace the hardcoded reference with proper NuGet package reference
          $oldRef = 'System.Reflection.Metadata, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" />'
          $newRef = 'System.Reflection.Metadata, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL"><HintPath>..\packages\System.Reflection.Metadata.8.0.0\lib\net462\System.Reflection.Metadata.dll</HintPath><Private>True</Private></Reference>'
          
          $content = $content -replace $oldRef, $newRef
          Set-Content $projectFile $content
          Write-Host "✅ Updated project reference with HintPath"

      - name: Build DirectOutput solution (x86 first, then x64)
        run: |
          # Build x86 first (as required by README_BuildSetup.md)
          Write-Host ">>> Building Release|x86 (required first for WiX dependencies)"
          
          # Clean x86 first
          Write-Host "Cleaning x86 build..."
          msbuild DirectOutput.sln -t:Clean -p:Configuration=Release -p:Platform=x86 -v:minimal -nologo
          if ($LASTEXITCODE -ne 0) { 
            Write-Error "x86 Clean failed"
            exit $LASTEXITCODE 
          }
          
          # Build x86 solution
          Write-Host "Building x86 solution..."
          msbuild DirectOutput.sln -t:Build -p:Configuration=Release -p:Platform=x86 -v:minimal -nologo
          if ($LASTEXITCODE -ne 0) { 
            Write-Error "x86 Solution build failed"
            exit $LASTEXITCODE 
          }
          Write-Host "✅ x86 build completed successfully"
          
          # Now build x64 (can read from x86 files as needed)
          Write-Host ">>> Building Release|x64 (can now use x86 dependencies)"
          
          # Clean x64
          Write-Host "Cleaning x64 build..."
          msbuild DirectOutput.sln -t:Clean -p:Configuration=Release -p:Platform=x64 -v:minimal -nologo
          if ($LASTEXITCODE -ne 0) { 
            Write-Error "x64 Clean failed"
            exit $LASTEXITCODE 
          }
          
          # Build x64 solution
          Write-Host "Building x64 solution..."
          msbuild DirectOutput.sln -t:Build -p:Configuration=Release -p:Platform=x64 -v:minimal -nologo
          if ($LASTEXITCODE -ne 0) { 
            Write-Error "x64 Solution build failed"
            exit $LASTEXITCODE 
          }
          Write-Host "✅ x64 build completed successfully"
          
          Write-Host "✅ All builds completed successfully (x86 and x64)"
          
          # Verify MSI files were created by MSBuild integration
          Write-Host ">>> Verifying WiX MSI Installers (built via MSBuild)"
          
          if (Test-Path "DOFSetup\bin\x86\Release\DOFSetup.msi") {
            $size = (Get-Item "DOFSetup\bin\x86\Release\DOFSetup.msi").Length
            Write-Host "✅ DOFSetup x86 MSI created via MSBuild ($([math]::Round($size/1MB,2)) MB)"
          } else {
            Write-Error "DOFSetup x86 MSI was not created by MSBuild"
            exit 1
          }
          
          if (Test-Path "DOFSetup\bin\x64\Release\DOFSetup.msi") {
            $size = (Get-Item "DOFSetup\bin\x64\Release\DOFSetup.msi").Length  
            Write-Host "✅ DOFSetup x64 MSI created via MSBuild ($([math]::Round($size/1MB,2)) MB)"
          } else {
            Write-Error "DOFSetup x64 MSI was not created by MSBuild"
            exit 1
          }

      - name: Create ZIP release packages
        run: |
          # Create ZIP packages for both x86 and x64
          @("x86", "x64") | ForEach-Object {
            $platform = $_
            $config = "Release"
            
            Write-Host "Creating ZIP package for $platform..."
            
            # Create output directory for ZIP package
            $outputDir = "output-zip-$platform-$config"
            New-Item -ItemType Directory -Path $outputDir -Force
            
            # Define source directory for binaries
            $binDir = "bin\$platform\$config"
            
            # Read manifest file and copy files
            $manifestFile = "manifest.$platform.txt"
            if (Test-Path $manifestFile) {
              Get-Content $manifestFile | Where-Object { $_ -notmatch "^#" -and $_.Trim() -ne "" } | ForEach-Object {
                $sourceFile = Join-Path $binDir $_
                
                # Handle x64 naming issue: MainDofDll -> DirectOutput.dll
                if ($platform -eq "x64" -and $_ -eq "DirectOutput.dll") {
                  $alternativeFile = Join-Path $binDir "MainDofDll"
                  if (-not (Test-Path $sourceFile) -and (Test-Path $alternativeFile)) {
                    Write-Host "Found x64 naming issue: copying MainDofDll as DirectOutput.dll"
                    Copy-Item $alternativeFile (Join-Path $outputDir "DirectOutput.dll") -Force
                    Write-Host "Copied: $alternativeFile -> DirectOutput.dll"
                    return
                  }
                }
                
                if (Test-Path $sourceFile) {
                  Copy-Item $sourceFile $outputDir -Force
                  Write-Host "Copied: $sourceFile"
                } else {
                  Write-Warning "File not found: $sourceFile"
                }
              }
            }
            
            # Copy additional files
            if (Test-Path "LICENSE") {
              Copy-Item "LICENSE" $outputDir -Force
            }
            
            # Copy config examples
            if (Test-Path "config\examples") {
              New-Item -ItemType Directory -Path "$outputDir\config\examples" -Force
              Copy-Item "config\examples\*.xml" "$outputDir\config\examples" -Force -ErrorAction SilentlyContinue
            }
            
            Write-Host "✅ ZIP package created for $platform"
          }

      - name: Create MSI release packages
        run: |
          # Create MSI packages for both x86 and x64
          @("x86", "x64") | ForEach-Object {
            $platform = $_
            $config = "Release"
            
            Write-Host "Creating MSI package for $platform..."
            
            # Create output directory for MSI package
            $outputDir = "output-msi-$platform-$config"
            New-Item -ItemType Directory -Path $outputDir -Force
            
            # Copy WiX 6 MSI installer (updated for new WiX 6 installers)
            $msiPath = "DOFSetup\bin\$platform\Release\DOFSetup.msi"
            if (Test-Path $msiPath) {
              $SHA7 = "${{ github.sha }}".Substring(0, 7)
              $DATE = Get-Date -Format "yyyyMMdd"
              $msiName = "DirectOutput-$platform-$config-$DATE-$SHA7.msi"
              Copy-Item $msiPath "$outputDir\$msiName" -Force
              Write-Host "Created MSI package: $msiName"
            } else {
              Write-Error "WiX 6 MSI installer not found at: $msiPath"
              exit 1
            }
            
            Write-Host "✅ MSI package processing completed for $platform"
          }

      - name: Upload x86 ZIP artifacts
        uses: actions/upload-artifact@v4
        with:
          name: DirectOutput-${{ steps.version.outputs.tag }}-Release-x86.zip
          path: output-zip-x86-Release
          if-no-files-found: warn

      - name: Upload x64 ZIP artifacts
        uses: actions/upload-artifact@v4
        with:
          name: DirectOutput-${{ steps.version.outputs.tag }}-Release-x64.zip
          path: output-zip-x64-Release
          if-no-files-found: warn

      - name: Upload x86 MSI artifacts
        uses: actions/upload-artifact@v4
        with:
          name: DirectOutput-${{ steps.version.outputs.tag }}-Release-x86.msi
          path: output-msi-x86-Release
          if-no-files-found: warn

      - name: Upload x64 MSI artifacts
        uses: actions/upload-artifact@v4
        with:
          name: DirectOutput-${{ steps.version.outputs.tag }}-Release-x64.msi
          path: output-msi-x64-Release
          if-no-files-found: warn

  create-github-release:
    name: Create GitHub Release
    runs-on: windows-2022
    needs: build
    if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main') && startsWith(github.ref, 'refs/tags/')
    
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release files
        run: |
          # Use version information from build job outputs
          $VERSION_LONG = "${{ needs.build.outputs.version-tag }}"
          $BASE_VERSION = "${{ needs.build.outputs.base-version }}"
          $DATE = Get-Date -Format "yyyyMMdd"
          
          Write-Host "Using version from build job: $VERSION_LONG (base: $BASE_VERSION)"
          
          # Create release directory
          New-Item -ItemType Directory -Path "release" -Force
          
          # Process ZIP artifacts and create final ZIP packages
          @("x86", "x64") | ForEach-Object {
            $platform = $_
            $zipArtifactPath = "artifacts\DirectOutput-$VERSION_LONG-Release-$platform.zip"
            
            if (Test-Path $zipArtifactPath) {
              $zipName = "DirectOutput-release-$platform-$DATE.zip"
              $zipPath = "release\$zipName"
              
              # Create ZIP using PowerShell
              Compress-Archive -Path "$zipArtifactPath\*" -DestinationPath $zipPath -Force
              Write-Host "Prepared release ZIP: $zipPath"
            } else {
              Write-Warning "ZIP artifact not found: $zipArtifactPath"
            }
          }
          
          # Copy MSI installers directly (no zipping needed for MSI files)
          @("x86", "x64") | ForEach-Object {
            $platform = $_
            $msiArtifactPath = "artifacts\DirectOutput-$VERSION_LONG-Release-$platform.msi"
            
            if (Test-Path $msiArtifactPath) {
              Get-ChildItem "$msiArtifactPath\*.msi" | ForEach-Object {
                Copy-Item $_.FullName "release\" -Force
                Write-Host "Copied MSI file: $($_.Name)"
              }
            } else {
              Write-Warning "MSI artifact not found: $msiArtifactPath (may be expected for $platform due to WiX limitations)"
            }
          }

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: release/*
          tag_name: ${{ github.ref_name }}
          name: DirectOutput ${{ github.ref_name }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
